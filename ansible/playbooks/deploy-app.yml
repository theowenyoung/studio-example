---
- name: Deploy Application Service
  hosts: all
  gather_facts: no

  vars:
    service_base: "{{ service_base }}"
    service_name: "{{ service_name }}"
    local_dist: "{{ playbook_dir }}/../../js-apps/{{ service_base }}/deploy-dist"
    remote_dir: "/srv/{{ service_name }}"

  tasks:
    - debug:
        msg: "ğŸš€ Deploying {{ service_name }}"

    - name: Ensure service directory exists
      file:
        path: "{{ remote_dir }}"
        state: directory
        owner: "{{ deploy_user | default('deploy') }}"
        group: "{{ deploy_user | default('deploy') }}"
        mode: '0755'

    # ===== Sync files =====
    - name: Sync deploy-dist to server
      synchronize:
        src: "{{ local_dist }}/"
        dest: "{{ remote_dir }}/"
        delete: yes
        owner: no
        group: no

    # ===== Docker operations =====
    - name: Login to ECR
      shell: |
        aws ecr get-login-password --region {{ ecr_region }} | \
          docker login --username AWS --password-stdin {{ ecr_registry }}
      environment:
        AWS_DEFAULT_REGION: "{{ ecr_region }}"
      changed_when: false

    - name: Pull new images
      shell: |
        cd {{ remote_dir }}
        docker compose pull --quiet
      register: pull_result
      changed_when: false

    # ===== Database migrations (optional) =====
    - name: Check if migrations service exists
      shell: |
        cd {{ remote_dir }}
        docker compose --profile migrate config --services 2>/dev/null | grep -q "{{ service_name }}-migrate"
      register: has_migrations
      failed_when: false
      changed_when: false

    - name: Run database migrations
      shell: |
        cd {{ remote_dir }}
        docker compose --profile migrate run --rm {{ service_name }}-migrate
      register: migrate_result
      when: has_migrations.rc == 0

    - name: Display migration output
      debug:
        msg: "{{ migrate_result.stdout_lines | default([]) }}"
      when: has_migrations.rc == 0 and migrate_result.stdout_lines is defined

    - name: Fail if migrations failed
      fail:
        msg: "âŒ Database migrations failed! Exit code: {{ migrate_result.rc }}"
      when:
        - has_migrations.rc == 0
        - migrate_result.rc is defined
        - migrate_result.rc != 0

    # ===== Deploy service with zero downtime =====
    - name: Zero-downtime deployment using docker-rollout
      shell: |
        cd {{ remote_dir }}
        docker rollout {{ service_name }} -t 90
      register: deploy_result
      failed_when: false

    - name: Display rollout output
      debug:
        msg: "{{ deploy_result.stdout_lines | default([]) }}"
      when: deploy_result.stdout_lines is defined and deploy_result.stdout_lines | length > 0

    # ===== Verify deployment =====
    - name: Verify container is running after rollout
      shell: |
        cd {{ remote_dir }}
        docker compose ps {{ service_name }} --format json 2>/dev/null | jq -r '.State // empty' | head -1
      register: container_state
      changed_when: false
      failed_when: false

    - name: Get container logs if deployment failed
      shell: |
        cd {{ remote_dir }}
        docker compose logs --tail=50 {{ service_name }}
      register: container_logs
      when: deploy_result.rc != 0 or (container_state.stdout != "running" and container_state.stdout != "running (healthy)")

    - name: Display container logs
      debug:
        msg: "{{ container_logs.stdout_lines }}"
      when: container_logs is defined and container_logs.stdout_lines is defined

    - name: Fail if deployment unsuccessful
      fail:
        msg: "âŒ Zero-downtime deployment of {{ service_name }} failed! Check logs above."
      when: deploy_result.rc != 0 or (container_state.stdout != "running" and container_state.stdout != "running (healthy)")

    - name: Display success message
      debug:
        msg: "âœ… Successfully deployed {{ service_name }} with zero downtime using docker-rollout"
      when: deploy_result.rc == 0 and (container_state.stdout == "running" or container_state.stdout == "running (healthy)")

    # ===== Preview Environment: Auto-generate Caddy config =====
    # routes is a JSON string: '[{"domain": "xxx", "path": "/xxx", "port": "3000"}, ...]'
    #
    # ç­–ç•¥ï¼šæ¯ä¸ª app ç”Ÿæˆç‹¬ç«‹çš„è·¯ç”±ç‰‡æ®µæ–‡ä»¶ï¼ŒæŒ‰ domain--service å‘½å
    # ç„¶åé€šè¿‡ assemble-caddy-routes.sh è„šæœ¬åˆå¹¶åŒåŸŸåçš„é…ç½®
    # è¿™æ ·æ”¯æŒå¤šä¸ª app å…±äº«åŒä¸€ä¸ªåŸŸåçš„ä¸åŒè·¯å¾„

    - name: Ensure Caddy routes directory exists
      file:
        path: /srv/caddy/config/preview/routes
        state: directory
        owner: "{{ deploy_user | default('deploy') }}"
        group: "{{ deploy_user | default('deploy') }}"
        mode: '0755'
      when: target_env == "preview" and (routes | from_json) | length > 0

    - name: Generate Caddy route snippets for preview environment
      copy:
        content: |
          # Route: {{ service_name }} -> {{ route.path }}
          # Auto-generated by deploy-app.yml
          {% if route.path == "/" %}
          handle {
              import app_cache
              import resilient_proxy {{ service_name }}:{{ route.port }}
          }
          {% else %}
          handle {{ route.path }}* {
              uri strip_prefix {{ route.path }}
              import app_cache
              import resilient_proxy {{ service_name }}:{{ route.port }}
          }
          {% endif %}
        dest: "/srv/caddy/config/preview/routes/{{ route.domain }}---{{ service_name }}.snippet"
        owner: "{{ deploy_user | default('deploy') }}"
        group: "{{ deploy_user | default('deploy') }}"
        mode: '0644'
      loop: "{{ routes | from_json }}"
      loop_control:
        loop_var: route
      when: target_env == "preview" and (routes | from_json) | length > 0
      register: caddy_snippets_created

    - name: Assemble Caddy config from route snippets
      shell: |
        cd /srv/caddy/config/preview

        # ç¡®ä¿ routes ç›®å½•å­˜åœ¨
        mkdir -p routes

        # è·å–æ‰€æœ‰å”¯ä¸€çš„åŸŸå
        # æ–‡ä»¶åæ ¼å¼: {domain}---{service_name}.snippet (ä¸‰æ¨ªçº¿åˆ†éš”)
        domains=$(ls routes/*.snippet 2>/dev/null | xargs -n1 basename | sed 's/\.snippet$//' | sed 's/---.*//' | sort -u)

        # ä¸ºæ¯ä¸ªåŸŸåç”Ÿæˆåˆå¹¶çš„ caddy é…ç½®
        for domain in $domains; do
          # æ”¶é›†è¯¥åŸŸåçš„æ‰€æœ‰è·¯ç”±ç‰‡æ®µ
          # æŒ‰è·¯å¾„é•¿åº¦æ’åºï¼ˆé•¿è·¯å¾„ä¼˜å…ˆåŒ¹é…ï¼‰ï¼Œ/ è·¯å¾„æ”¾æœ€å
          {
            echo "# Domain: $domain"
            echo "# Auto-assembled from route snippets"
            echo "$domain {"

            # å…ˆè¾“å‡ºå­è·¯å¾„çš„ handle /path* (ä¸æ˜¯ handle {)
            for snippet in routes/${domain}---*.snippet; do
              [ -f "$snippet" ] || continue
              if grep -q "^handle /" "$snippet"; then
                grep -v "^#" "$snippet"
              fi
            done

            # æœ€åè¾“å‡ºæ ¹è·¯å¾„çš„ handle {ï¼ˆä½œä¸º fallbackï¼‰
            for snippet in routes/${domain}---*.snippet; do
              [ -f "$snippet" ] || continue
              if grep -q "^handle {" "$snippet"; then
                grep -v "^#" "$snippet"
              fi
            done

            echo "}"
          } > "${domain}.caddy"

          echo "âœ… Assembled ${domain}.caddy"
        done
      when: target_env == "preview" and caddy_snippets_created.changed
      register: caddy_assemble_result

    - name: Display assemble output
      debug:
        msg: "{{ caddy_assemble_result.stdout_lines | default([]) }}"
      when: target_env == "preview" and caddy_assemble_result.stdout_lines is defined

    - name: Reload Caddy config for preview environment
      shell: |
        cd /srv/caddy
        docker compose exec -T caddy caddy reload --config /etc/caddy/Caddyfile
      when: target_env == "preview" and caddy_snippets_created.changed
      register: caddy_reload_result
      failed_when: false

    - name: Display Caddy reload status
      debug:
        msg: "ğŸ”„ Caddy config reloaded for {{ (routes | from_json) | map(attribute='domain') | join(', ') }}"
      when: target_env == "preview" and caddy_snippets_created.changed
