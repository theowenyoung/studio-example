name: Deploy External Applications

on:
  # Push è§¦å‘ï¼ˆä»… main åˆ†æ”¯ï¼ŒæŒ‰ app è·¯å¾„è¿‡æ»¤ï¼‰
  push:
    branches:
      - main
    paths:
      - 'external-apps/**'

  # PR è§¦å‘
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'external-apps/**'

  # æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      service:
        description: "External app to deploy (app name or 'all')"
        required: true
        type: string
        default: "all"

  # Webhook è§¦å‘ï¼ˆä¾‹å¦‚ï¼šåšå®¢ä»“åº“æ›´æ–°åŽè§¦å‘ï¼‰
  repository_dispatch:
    types: [deploy-external-app]

env:
  ECR_REGISTRY: YOUR_AWS_ACCOUNT_ID.dkr.ecr.us-west-2.amazonaws.com

jobs:
  # æ£€æµ‹éƒ¨ç½²çŽ¯å¢ƒ
  detect:
    runs-on: ubuntu-latest
    outputs:
      deploy_env: ${{ steps.set-env.outputs.deploy_env }}
      branch_clean: ${{ steps.set-env.outputs.branch_clean }}
    steps:
      - name: Determine deployment environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BRANCH="${{ github.head_ref }}"
            DEPLOY_ENV="preview"
          elif [ "${{ github.ref_name }}" = "main" ]; then
            BRANCH="main"
            DEPLOY_ENV="prod"
          else
            BRANCH="${{ github.ref_name }}"
            DEPLOY_ENV="preview"
          fi

          # æ¸…æ´—åˆ†æ”¯å
          BRANCH_CLEAN=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]' | cut -c1-30)

          echo "deploy_env=$DEPLOY_ENV" >> $GITHUB_OUTPUT
          echo "branch_clean=$BRANCH_CLEAN" >> $GITHUB_OUTPUT
          echo "Deploy environment: $DEPLOY_ENV"
          echo "Branch: $BRANCH (clean: $BRANCH_CLEAN)"

  # å‰ç½®ï¼šç¡®ä¿æ•°æ®åº“å­˜åœ¨ï¼ˆåªè¿è¡Œä¸€æ¬¡ï¼Œé¿å…å¹¶è¡Œå†²çªï¼‰
  db-prepare:
    needs: detect
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache mise
        uses: actions/cache@v4
        with:
          path: ~/.local/share/mise
          key: mise-${{ runner.os }}-${{ hashFiles('.mise/config.toml') }}

      - name: Install mise
        run: |
          curl https://mise.run | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Setup mise
        run: |
          mise install

      - name: Cache Ansible Galaxy dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.ansible/roles
            ~/.ansible/collections
          key: ansible-galaxy-${{ hashFiles('ansible/requirements.yml') }}

      - name: Install Ansible Galaxy dependencies
        run: |
          ansible-galaxy install -r ansible/requirements.yml

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Load SSH key from Parameter Store
        run: |
          if [ "${{ needs.detect.outputs.deploy_env }}" = "prod" ]; then
            PARAM_PATH="/studio-prod/"
          else
            PARAM_PATH="/studio-dev/"
          fi

          DEPLOY_SSH_KEY=$(aws ssm get-parameter --name "${PARAM_PATH}DEPLOY_SSH_KEY" --with-decryption --query "Parameter.Value" --output text)

          mkdir -p ~/.ssh
          echo "${DEPLOY_SSH_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          echo "âœ… SSH key loaded (env: ${{ needs.detect.outputs.deploy_env }})"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region us-west-2 | \
            docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Run db-prepare (ensure databases exist)
        run: |
          mise run deploy-db-prepare
        env:
          ANSIBLE_SSH_PRIVATE_KEY_FILE: ~/.ssh/id_rsa

  deploy:
    needs: [detect, db-prepare]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2  # éœ€è¦è‡³å°‘ 2 ä¸ª commit æ¥æ¯”è¾ƒå˜æ›´

      # ç¼“å­˜ mise å·¥å…·
      - name: Cache mise
        uses: actions/cache@v4
        with:
          path: ~/.local/share/mise
          key: mise-${{ runner.os }}-${{ hashFiles('.mise/config.toml') }}

      # å®‰è£… mise
      - name: Install mise
        run: |
          curl https://mise.run | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      # æ¿€æ´» mise çŽ¯å¢ƒ
      - name: Setup mise
        run: |
          mise install

      # ç¼“å­˜ Ansible Galaxy ä¾èµ–
      - name: Cache Ansible Galaxy dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.ansible/roles
            ~/.ansible/collections
          key: ansible-galaxy-${{ hashFiles('ansible/requirements.yml') }}

      # å®‰è£… Ansible Galaxy ä¾èµ–
      - name: Install Ansible Galaxy dependencies
        run: |
          ansible-galaxy install -r ansible/requirements.yml

      # é…ç½® AWSï¼ˆç”¨äºŽ ECR å’Œ Parameter Storeï¼‰
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.CI_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.CI_AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      # ä»Ž Parameter Store è¯»å– SSH Key
      - name: Load SSH key from Parameter Store
        run: |
          # æ ¹æ®çŽ¯å¢ƒé€‰æ‹©é…ç½®è·¯å¾„
          if [ "${{ needs.detect.outputs.deploy_env }}" = "prod" ]; then
            PARAM_PATH="/studio-prod/"
          else
            PARAM_PATH="/studio-dev/"
          fi

          DEPLOY_SSH_KEY=$(aws ssm get-parameter --name "${PARAM_PATH}DEPLOY_SSH_KEY" --with-decryption --query "Parameter.Value" --output text)

          # ä¿å­˜ SSH key åˆ°æ–‡ä»¶
          mkdir -p ~/.ssh
          echo "${DEPLOY_SSH_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          echo "âœ… SSH key loaded (env: ${{ needs.detect.outputs.deploy_env }})"

      # ç™»å½• ECR
      - name: Login to ECR
        run: |
          aws ecr get-login-password --region us-west-2 | \
            docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      # è®¾ç½® Docker Buildxï¼ˆç”¨äºŽç¼“å­˜ï¼‰
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # ç¡®å®šè¦éƒ¨ç½²çš„æœåŠ¡
      - name: Determine deployment target
        id: target
        run: |
          # workflow_dispatch è§¦å‘
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SERVICE="${{ inputs.service }}"
          # repository_dispatch è§¦å‘ï¼ˆä»Ž webhook payload è¯»å–ï¼‰
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            SERVICE="${{ github.event.client_payload.service }}"
            if [ -z "$SERVICE" ]; then
              echo "âŒ Error: service not specified in webhook payload"
              exit 1
            fi
          # push æˆ– pull_request è§¦å‘ï¼ˆæ£€æµ‹å“ªäº› app æœ‰å˜æ›´ï¼‰
          elif [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "pull_request" ]; then
            # èŽ·å–å˜æ›´çš„æ–‡ä»¶åˆ—è¡¨
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              # PR: æ¯”è¾ƒ base å’Œ head
              CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...${{ github.head_ref }} 2>/dev/null || git diff --name-only HEAD~1 HEAD)
            else
              # Push: æ¯”è¾ƒå‰åŽ commit
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || git diff --name-only HEAD~1 HEAD)
            fi
            echo "Changed files:"
            echo "$CHANGED_FILES"

            # æ£€æµ‹å“ªäº› external-apps æœ‰å˜æ›´ï¼ˆåŠ¨æ€æ‰«ææœ‰ build.sh çš„ç›®å½•ï¼‰
            CHANGED_APPS=""
            for app_dir in external-apps/*/; do
              app=$(basename "$app_dir")
              # åªå¤„ç†æœ‰ build.sh çš„ app
              if [ -f "${app_dir}build.sh" ] && echo "$CHANGED_FILES" | grep -q "^external-apps/${app}/"; then
                CHANGED_APPS="${CHANGED_APPS} ${app}"
              fi
            done

            # åŽ»é™¤å‰å¯¼ç©ºæ ¼
            CHANGED_APPS=$(echo "$CHANGED_APPS" | xargs)

            if [ -z "$CHANGED_APPS" ]; then
              echo "âš ï¸ No external-apps changes detected, skipping deployment"
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            # å¦‚æžœåªæœ‰ä¸€ä¸ª app å˜æ›´ï¼Œç›´æŽ¥ç”¨å®ƒï¼›å¦åˆ™ç”¨ç©ºæ ¼åˆ†éš”çš„åˆ—è¡¨
            SERVICE="$CHANGED_APPS"
            echo "ðŸ“¦ Detected changes in: ${SERVICE}"
          fi

          echo "service=${SERVICE}" >> $GITHUB_OUTPUT
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Deploying: ${SERVICE}"

      # éƒ¨ç½²æœåŠ¡
      - name: Deploy ${{ steps.target.outputs.service }}
        if: steps.target.outputs.skip != 'true'
        run: |
          SERVICE="${{ steps.target.outputs.service }}"

          if [ "$SERVICE" = "all" ]; then
            echo "ðŸš€ Deploying all external apps..."
            for app_dir in external-apps/*/; do
              if [ -f "${app_dir}build.sh" ]; then
                app=$(basename "$app_dir")
                echo "Deploying ${app}..."
                mise run build-${app}
                mise run deploy-${app}
              fi
            done
          else
            # SERVICE å¯èƒ½æ˜¯å•ä¸ª app æˆ–ç©ºæ ¼åˆ†éš”çš„å¤šä¸ª app
            echo "ðŸš€ Deploying: ${SERVICE}"
            for app in $SERVICE; do
              echo "Deploying ${app}..."
              mise run build-${app}
              mise run deploy-${app}
            done
          fi
        env:
          DOCKER_BUILDKIT: 1
          BUILDKIT_PROGRESS: plain
          ANSIBLE_SSH_PRIVATE_KEY_FILE: ~/.ssh/id_rsa

      # è¿è¡Œ post-deploy hooksï¼ˆå¦‚æžœå­˜åœ¨ï¼‰
      - name: Run post-deploy hooks
        if: steps.target.outputs.skip != 'true'
        run: |
          SERVICE="${{ steps.target.outputs.service }}"

          run_post_deploy() {
            local app=$1
            if [ -f "external-apps/${app}/post-deploy.sh" ]; then
              echo "ðŸ”§ Running post-deploy for ${app}..."
              mise run post-deploy-${app}
            fi
          }

          if [ "$SERVICE" = "all" ]; then
            for app_dir in external-apps/*/; do
              if [ -f "${app_dir}build.sh" ]; then
                app=$(basename "$app_dir")
                run_post_deploy "$app"
              fi
            done
          else
            for app in $SERVICE; do
              run_post_deploy "$app"
            done
          fi

      # éƒ¨ç½²ç»“æžœé€šçŸ¥
      - name: Deployment summary
        if: always() && steps.target.outputs.skip != 'true'
        run: |
          SERVICE="${{ steps.target.outputs.service }}"

          echo "### External App Deployment Result ðŸŒ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ä»Ž DEPLOY_SUMMARY.txt è¯»å– URL
          if [ "$SERVICE" = "all" ]; then
            # éƒ¨ç½²æ‰€æœ‰æœåŠ¡æ—¶ï¼Œåˆå¹¶æ‰€æœ‰ summary
            echo "ðŸ”— **URLs:**" >> $GITHUB_STEP_SUMMARY
            for app_dir in external-apps/*/; do
              if [ -f "${app_dir}build.sh" ]; then
                app=$(basename "$app_dir")
                SUMMARY_FILE="${app_dir}deploy-dist/DEPLOY_SUMMARY.txt"
                if [ -f "$SUMMARY_FILE" ]; then
                  while IFS= read -r url; do
                    echo "- [${url}](${url})" >> $GITHUB_STEP_SUMMARY
                  done < "$SUMMARY_FILE"
                else
                  echo "- ${app} (internal service)" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          else
            # SERVICE å¯èƒ½æ˜¯å•ä¸ª app æˆ–ç©ºæ ¼åˆ†éš”çš„å¤šä¸ª app
            echo "ðŸ”— **URLs:**" >> $GITHUB_STEP_SUMMARY
            for app in $SERVICE; do
              SUMMARY_FILE="external-apps/${app}/deploy-dist/DEPLOY_SUMMARY.txt"
              if [ -f "$SUMMARY_FILE" ]; then
                while IFS= read -r url; do
                  echo "- [${url}](${url})" >> $GITHUB_STEP_SUMMARY
                done < "$SUMMARY_FILE"
              else
                echo "- ${app} (internal service)" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- Service: \`${SERVICE}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: \`${{ needs.detect.outputs.deploy_env }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- Trigger: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "- Triggered by: Webhook" >> $GITHUB_STEP_SUMMARY
            echo "- Source repo: ${{ github.event.client_payload.repository || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Triggered by: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          fi

          echo "- Commit: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY

      # ä¸Šä¼  DEPLOY_SUMMARY.txt ä¾› PR comment ä½¿ç”¨
      - name: Upload deploy summaries
        if: github.event_name == 'pull_request' && steps.target.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: external-app-deploy-summaries
          path: external-apps/*/deploy-dist/DEPLOY_SUMMARY.txt
          if-no-files-found: ignore
          retention-days: 1

  # PR è¯„è®ºé¢„è§ˆ URL
  comment:
    needs: [detect, deploy]
    if: github.event_name == 'pull_request' && needs.detect.outputs.deploy_env == 'preview'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      # ä¸‹è½½ deploy-summary artifacts
      - name: Download deploy summaries
        uses: actions/download-artifact@v4
        with:
          name: external-app-deploy-summaries
          path: summaries
        continue-on-error: true

      # è¯»å–æ‰€æœ‰ URL å¹¶ç”Ÿæˆè¯„è®º
      - name: Comment preview URLs on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const branchClean = '${{ needs.detect.outputs.branch_clean }}';

            // ä»Ž artifacts è¯»å–çœŸå®ž URL
            const urlLines = [];
            const summariesDir = 'summaries';

            if (fs.existsSync(summariesDir)) {
              // éåŽ† external-apps ç›®å½•ç»“æž„
              const walkDir = (dir) => {
                if (!fs.existsSync(dir)) return;
                const items = fs.readdirSync(dir, { withFileTypes: true });
                for (const item of items) {
                  const fullPath = path.join(dir, item.name);
                  if (item.isDirectory()) {
                    walkDir(fullPath);
                  } else if (item.name === 'DEPLOY_SUMMARY.txt') {
                    // ä»Žè·¯å¾„æå– app åç§° (DEPLOY_SUMMARY.txt åœ¨ deploy-dist/ ç›®å½•ä¸‹ï¼Œæ‰€ä»¥å¾€ä¸Šä¸¤çº§å°±æ˜¯ app åç§°)
                    const deployDistDir = path.dirname(fullPath);
                    const appDir = path.dirname(deployDistDir);
                    const appName = path.basename(appDir);
                    try {
                      const content = fs.readFileSync(fullPath, 'utf8').trim();
                      const urls = content.split('\n').filter(u => u.length > 0);
                      if (urls.length === 1) {
                        urlLines.push(`- **${appName}**: ${urls[0]}`);
                      } else if (urls.length > 1) {
                        urlLines.push(`- **${appName}**:`);
                        urls.forEach(url => urlLines.push(`  - ${url}`));
                      }
                    } catch (e) {
                      console.log(`Failed to read ${fullPath}: ${e.message}`);
                    }
                  }
                }
              };
              walkDir(summariesDir);
            }

            if (urlLines.length === 0) {
              console.log('No deploy summaries found, skipping PR comment');
              return;
            }

            const body = `## ðŸŒ External App Preview Deployment

            Your changes have been deployed to the preview environment!

            ### Preview URLs
            ${urlLines.join('\n')}

            ### Details
            - **Branch**: \`${{ github.head_ref }}\`
            - **Commit**: \`${{ github.sha }}\`
            - **Environment**: preview

            > â„¹ï¸ Preview environments are automatically cleaned up when the PR is merged or closed.
            `;

            // æŸ¥æ‰¾å·²æœ‰çš„è¯„è®º
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('External App Preview Deployment')
            );

            if (botComment) {
              // æ›´æ–°å·²æœ‰è¯„è®º
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // åˆ›å»ºæ–°è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
