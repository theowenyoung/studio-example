#!/bin/bash
set -e

# Load common functions
source "$(dirname "$0")/build-lib.sh"

# Get service name from argument
SERVICE_BASE=$1
if [ -z "$SERVICE_BASE" ]; then
    echo "‚ùå Error: Service name is required"
    echo "Usage: $0 <service-name>"
    exit 1
fi

# Change to service directory and detect environment
# This sets CTX_SERVICE_NAME based on the directory
cd "js-apps/$SERVICE_BASE" || cd "infra-apps/$SERVICE_BASE" || cd "external-apps/$SERVICE_BASE" || {
    echo "‚ùå Error: Service directory not found: $SERVICE_BASE"
    exit 1
}

detect_environment

# Generate resource names
# Preview ÁéØÂ¢É‰ΩøÁî®ÂèåÂàÜÈöîÁ¨¶ (-- Âíå __) ‰æø‰∫éËß£Êûê
if [ "$DEPLOY_ENV" = "preview" ]; then
    SERVICE_NAME="${SERVICE_BASE}--${BRANCH_CLEAN}"
    DATABASE_NAME=$(echo "${SERVICE_BASE}" | tr '-' '_')"__${BRANCH_CLEAN//-/_}"
else
    SERVICE_NAME="${SERVICE_BASE}"
    DATABASE_NAME=$(echo "${SERVICE_BASE}" | tr '-' '_')
fi

# Read routes from deploy-dist/DEPLOY_ROUTES.txt (single source of truth)
# Format: domain|path|port per line
# Generated by build.sh -> generate_deploy_summary() from .env.example
ROUTES_FILE="deploy-dist/DEPLOY_ROUTES.txt"
SUMMARY_FILE="deploy-dist/DEPLOY_SUMMARY.txt"
ENV_FILE="deploy-dist/.env"

if [ ! -f "$ROUTES_FILE" ]; then
    echo "‚ùå Error: $ROUTES_FILE not found. Run build.sh first."
    exit 1
fi

# Read DEPLOY_SERVER from deploy-dist/.env (optional, defaults to prod1)
# Only applies to prod environment; preview always uses 'preview' server
if [ "$DEPLOY_ENV" = "prod" ] && [ -f "$ENV_FILE" ]; then
    DEPLOY_SERVER=$(grep "^DEPLOY_SERVER=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2- || true)
    DEPLOY_SERVER="${DEPLOY_SERVER:-prod1}"
else
    DEPLOY_SERVER="$ANSIBLE_TARGET"
fi

# Read routes into a JSON array for Ansible
# Format: [{"domain": "xxx", "path": "/xxx", "port": "3000"}, ...]
ROUTES_JSON="["
first=true
while IFS='|' read -r domain path port; do
    [ -z "$domain" ] && continue
    if [ "$first" = true ]; then
        first=false
    else
        ROUTES_JSON+=","
    fi
    ROUTES_JSON+="{\"domain\":\"$domain\",\"path\":\"$path\",\"port\":\"$port\"}"
done < "$ROUTES_FILE"
ROUTES_JSON+="]"

# Get primary domain for display (first one)
PRIMARY_DOMAIN=$(head -1 "$ROUTES_FILE" | cut -d'|' -f1)

# Display deployment info
echo "üöÄ Deploying $SERVICE_BASE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "   Environment:  $DEPLOY_ENV"
echo "   Server:       $DEPLOY_SERVER"
echo "   Branch:       $CURRENT_BRANCH"
echo "   Service:      $SERVICE_NAME"
echo "   Database:     $DATABASE_NAME"
echo "   Routes:"
while IFS='|' read -r domain path port; do
    [ -z "$domain" ] && continue
    echo "     - https://${domain}${path} -> :$port"
done < "$ROUTES_FILE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

# Return to repo root for ansible
cd "$(git rev-parse --show-toplevel)"

# Run Ansible playbook
# ‰ΩøÁî® -l ÈôêÂà∂ÁõÆÊ†á‰∏ªÊú∫ÔºàÂèØË¢´ÁéØÂ¢ÉÂèòÈáè ANSIBLE_LIMIT Ë¶ÜÁõñÔºâ
LIMIT=${ANSIBLE_LIMIT:-$DEPLOY_SERVER}

ansible-playbook -i ansible/inventory.yml \
  ansible/playbooks/deploy-app.yml \
  -e service_base="$SERVICE_BASE" \
  -e service_name="$SERVICE_NAME" \
  -e database_name="$DATABASE_NAME" \
  -e "routes=$ROUTES_JSON" \
  -e target_env="$DEPLOY_ENV" \
  -e branch_name="$BRANCH_CLEAN" \
  -l "$LIMIT"

echo ""
echo "‚úÖ Deployed successfully!"
# Display all URLs
if [ -f "js-apps/$SERVICE_BASE/$SUMMARY_FILE" ]; then
    echo "üåê URLs:"
    while read -r url; do
        echo "   $url"
    done < "js-apps/$SERVICE_BASE/$SUMMARY_FILE"
else
    echo "üåê Visit: https://$PRIMARY_DOMAIN"
fi
